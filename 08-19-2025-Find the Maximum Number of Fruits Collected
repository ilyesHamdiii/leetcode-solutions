#https://leetcode.com/problems/find-the-maximum-number-of-fruits-collected/description/
# Difficulty:Hard
# Time:o(n)
# 
# # Space:O(n)
# Python

class Solution:
    def maxCollectedFruits(self, fruits: List[List[int]]) -> int:
        n = len(fruits)
        res = self.collectDiagonalFruits(fruits, n)
        
        # Calculate maximum fruits collected from the bottom and right
        dp_bottom, dp_right = self.initializeDP(fruits, n)
        # Maximum reachable positions for the children
        max_reachable = 2
        
        # Update DP arrays for the remaining rows
        for i in range(1, n - 1):
            dp_bottom, dp_right, max_reachable = self.updateDP(fruits, dp_bottom, dp_right, i, max_reachable, n)
        
        # Return the total fruits collected
        return res + dp_right[0] + dp_bottom[0]


    def collectDiagonalFruits(self, fruits: List[List[int]], n: int) -> int:
        """Collect fruits from the main diagonal."""
        total_fruits = 0
        for i in range(n):
            total_fruits += fruits[i][i]
        return total_fruits


    def initializeDP(self, fruits: List[List[int]], n: int) -> (List[int], List[int]):
        """Initialize DP arrays for bottom and right movements."""
        # Starting fruits collected from the bottom left corner
        dp_bottom = [fruits[n - 1][0], 0, 0]
        # Starting fruits collected from the top right corner
        dp_right = [fruits[0][n - 1], 0, 0]
        return dp_bottom, dp_right


    def updateDP(self, fruits: List[List[int]], dp_bottom: List[int], dp_right: List[int], i: int, max_reachable: int, n:int) -> (List[int], List[int], int):
        """Update DP arrays for the current row."""
        dp_bottom_new = [0] * (max_reachable + 2)  # New DP array for bottom movements
        dp_right_new = [0] * (max_reachable + 2)   # New DP array for right movements
        
        # Update the DP arrays for the current row
        for j in range(max_reachable):
            # Calculate maximum fruits collected for the bottom child
            dp_bottom_new[j] = max(dp_bottom[j - 1], dp_bottom[j], dp_bottom[j + 1]) + fruits[n - 1 - j][i]
            
            # Calculate maximum fruits collected for the right child
            dp_right_new[j] = max(dp_right[j - 1], dp_right[j], dp_right[j + 1]) + fruits[i][n - 1 - j]
        
        # Move to the next row by updating the DP arrays
        dp_bottom = dp_bottom_new
        dp_right = dp_right_new
        
        # Adjust the maximum reachable positions based on the current iteration
        if max_reachable - n + 4 + i <= 1:
            max_reachable += 1
        elif max_reachable - n + 3 + i > 1:
            max_reachable -= 1
        
        return dp_bottom, dp_right, max_reachable